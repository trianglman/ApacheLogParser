<?php

namespace apacheLogParser;
require_once 'Mockery/Loader.php';
require_once 'Hamcrest/Hamcrest.php';
use \Mockery as m;
$loader = new m\Loader;
$loader->register();

/**
 * Test class for ApacheLogFile.
 * Generated by PHPUnit on 2012-03-22 at 23:51:45.
 */
class ApacheLogFileTest extends \PHPUnit_Framework_TestCase {
    
    /**
     * @var ApacheLogFile
     */
    protected $object;
    
    /**
     * Log formats to be used for testing
     * @var array[string]string
     */
    protected $logFormats=array();
    /**
     * Paths to the log files to be used for testing
     * @var array[string]string
     */
    protected $logFiles = array();
    
    /**
     * Mock of the ApacheLogRecord to be used in testing
     * @var ApacheLogRecord
     */
    protected $recordMock = null;

    protected function setUp() {
        //Common Apache log formats
        $this->logFormats['common']="%h %l %u %t \\\"%r\\\" %>s %b";
        $this->logFormats['combined']="%h %l %u %t \\\"%r\\\" %>s %b "
                ."\\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"";
        //tests that all basic parameters gets translated properly
        $this->logFormats['allStandard']="%% %a %A %b %B %D \\\"%f\\\" %h %l "
                ."%m %p %q \\\"%r\\\" %s %t %T \\\"%u\\\" \\\"%U\\\" \\\"%v\\\" "
                ."\\\"%V\\\" %X %I %O";
        //Tests that all formats that accept a segment are captured
        $this->logFormats['allSegmented']="\\\"%{foo}C\\\" \\\"%{foo}e\\\" "
                ."\\\"%{Referer}i\\\" \\\"%{foo}n\\\" \\\"%{Server}o\\\" "
                ."\\\"%{tid}P\\\" \\\"%{pid}P\\\" \\\"%>s\\\"";
        //tests that logging conditions are ignored
        $this->logFormats['conditional']="\\\"%!200,304,302{Referer}i\\\"";
        //log files to match each of the log formats
        $this->logFiles['common']=dirname(__FILE__).'/testAssets/commonlog';
        $this->logFiles['combined']=dirname(__FILE__).'/testAssets/combinedlog';
        $this->logFiles['allStandard']=dirname(__FILE__).'/testAssets/allStandardlog';
        $this->logFiles['allSegmented']=dirname(__FILE__).'/testAssets/allSegmentedlog';
        $this->logFiles['conditional']=dirname(__FILE__).'/testAssets/conditionallog';
        $this->object = new ApacheLogFile('','');
        
    }

    public function teardown()
    {
        m::close();
    }


    public function testProcessApacheLogCommandBasic()
    {
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_processApacheLogCommand'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $expectedFinalArray = array('remoteIP','localIP','respBytes','respBytes',
            'respMicro','filename','clientIP','remoteLogname','reqMethod','port',
            'queryString','request','firstStatus','reqTime','respSec','user',
            'url','serverName','useCanonicalServerName','completeConnStatus',
            'libIOBytesIn','libIOBytesOut');
        $this->assertEquals(0,count($prop->getValue($this->object)));
        $this->assertEquals('%', $method->invoke($this->object,'%',''));
        $this->assertEquals(0,count($prop->getValue($this->object)));
        $this->assertEquals('(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', 
                $method->invoke($this->object,'a',''));
        $this->assertEquals(1,count($prop->getValue($this->object)));
        $this->assertEquals('(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', 
                $method->invoke($this->object,'A',''));
        $this->assertEquals(2,count($prop->getValue($this->object)));
        $this->assertEquals('(\S+)', $method->invoke($this->object,'b',''));
        $this->assertEquals('(\d*)', $method->invoke($this->object,'B',''));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'D',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'f',''));
        $this->assertEquals('(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
                $method->invoke($this->object,'h',''));
        $this->assertEquals('(-)',$method->invoke($this->object,'l',''));
        $this->assertEquals('(GET|POST|PUT|HEAD|OPTIONS|DELETE|TRACE|CONNECT)',
                $method->invoke($this->object,'m',''));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'p',''));
        $this->assertEquals('(\S*)',$method->invoke($this->object,'q',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'r',''));
        $this->assertEquals('(\d{3})',$method->invoke($this->object,'s',''));
        $this->assertEquals('\[(.*)\]',$method->invoke($this->object,'t',''));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'T',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'u',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'U',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'v',''));
        $this->assertEquals('(.*)',$method->invoke($this->object,'V',''));
        $this->assertEquals('(X|\+|-)',$method->invoke($this->object,'X',''));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'I',''));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'O',''));
        
        $this->assertEquals($expectedFinalArray,$prop->getValue($this->object));
    }
    
    /**
     * @depends testProcessApacheLogCommandBasic
     */
    public function testProcessApacheLogCommandSegments()
    {
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_processApacheLogCommand'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $expectedFinalArray = array('cookie:foo','environment:foo',
            'reqHeader:Referer','module:foo','respHeader:Server','tid','pid',
            'lastStatus');
        $this->assertEquals(0,count($prop->getValue($this->object)));
        $this->assertEquals('(.*)',$method->invoke($this->object,'C','{foo}'));
        $this->assertEquals('(.*)',$method->invoke($this->object,'e','{foo}'));
        $this->assertEquals('(.*)',$method->invoke($this->object,'i','{Referer}'));
        $this->assertEquals('(.*)',$method->invoke($this->object,'n','{foo}'));
        $this->assertEquals('(.*)',$method->invoke($this->object,'o','{Server}'));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'P','{tid}'));
        $this->assertEquals('(\d*)',$method->invoke($this->object,'P','{pid}'));
        $this->assertEquals('(\d{3})',$method->invoke($this->object,'s','>'));

        $this->assertEquals($expectedFinalArray,$prop->getValue($this->object));
    }
    
    /**
     * @depends testProcessApacheLogCommandBasic
     */
    public function testConvertFormatToRegExCommon(){
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_convertFormatToRegEx'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $log = new ApacheLogFile('',$this->logFormats['common']);
        $expectedFinalArray=array('clientIP','remoteLogname','user','reqTime',
            'request','lastStatus','respBytes');
        $this->assertEquals('/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) (-) (.*) '
                            .'\[(.*)\] \\"(.*)\\" (\d{3}) (\S+)$/Umi',
                $method->invoke($log));
        $this->assertEquals($expectedFinalArray,$prop->getValue($log));
    }

    /**
     * @depends testProcessApacheLogCommandSegments
     */
    public function testConvertFormatToRegExCombined(){
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_convertFormatToRegEx'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $log = new ApacheLogFile('',$this->logFormats['combined']);
        $expectedFinalArray=array('clientIP','remoteLogname','user','reqTime',
            'request','lastStatus','respBytes','reqHeader:Referer',
            'reqHeader:User-Agent');
        $this->assertEquals('/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) (-) (.*) '
                            .'\[(.*)\] \\"(.*)\\" (\d{3}) (\S+) '
                            .'\\"(.*)\\" \\"(.*)\\"$/Umi',
                $method->invoke($log));
        $this->assertEquals($expectedFinalArray,$prop->getValue($log));
    }

    /**
     * @depends testProcessApacheLogCommandBasic
     */
    public function testConvertFormatToRegExAllStandard(){
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_convertFormatToRegEx'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $log = new ApacheLogFile('',$this->logFormats['allStandard']);
        $expectedFinalArray = array('remoteIP','localIP','respBytes','respBytes',
            'respMicro','filename','clientIP','remoteLogname','reqMethod','port',
            'queryString','request','firstStatus','reqTime','respSec','user',
            'url','serverName','useCanonicalServerName','completeConnStatus',
            'libIOBytesIn','libIOBytesOut');
        $this->assertEquals('/^% (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) '
                            .'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) (\S+) (\d*) '
                            .'(\d*) \\"(.*)\\" (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) '
                            .'(-) (GET|POST|PUT|HEAD|OPTIONS|DELETE|TRACE|CONNECT) '
                            .'(\d*) (\S*) \\"(.*)\\" (\d{3}) \[(.*)\] (\d*) '
                            .'\\"(.*)\\" \\"(.*)\\" \\"(.*)\\" \\"(.*)\\" '
                            .'(X|\+|-) (\d*) (\d*)$/Umi',
                $method->invoke($log));
        $this->assertEquals($expectedFinalArray,$prop->getValue($log));
    }

    /**
     * @depends testProcessApacheLogCommandSegments
     */
    public function testConvertFormatToRegExAllSegmented(){
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_convertFormatToRegEx'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $log = new ApacheLogFile('',$this->logFormats['allSegmented']);
        $expectedFinalArray = array('cookie:foo','environment:foo',
            'reqHeader:Referer','module:foo','respHeader:Server','tid','pid',
            'lastStatus');
        $this->assertEquals('/^\\"(.*)\\" \\"(.*)\\" \\"(.*)\\" \\"(.*)\\" '
                .'\\"(.*)\\" \\"(\d*)\\" \\"(\d*)\\" \\"(\d{3})\\"$/Umi',
                $method->invoke($log));
        $this->assertEquals($expectedFinalArray,$prop->getValue($log));
    }

    /**
     * @depends testProcessApacheLogCommandSegments
     */
    public function testConvertFormatToRegExConditional(){
        //sets the internals to accessible for testing
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_convertFormatToRegEx'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','logPieces');
        $prop->setAccessible(true);
        
        $log = new ApacheLogFile('',$this->logFormats['conditional']);
        $this->assertEquals('/^\\"(.*)\\"$/Umi',$method->invoke($log));
        $this->assertEquals(array('reqHeader:Referer'),$prop->getValue($log));
    }
    
    /**
     * @depends testConvertFormatToRegExCommon
     */
    public function testParseLogCommonOne(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')->once()
            ->with('clientIP','127.0.0.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('remoteLogname','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('user','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqTime','24/Mar/2012:22:36:29 -0500')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('request','GET /activity/styles/global.css HTTP/1.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('lastStatus','200')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respBytes','725')->ordered();
        $recordMock->shouldReceive('logValue')->zeroOrMoreTimes()
            ->with(m::type('string'),m::type('string'))->ordered();
        //set up test object
        $logFile = explode("\n", file_get_contents($this->logFiles['common']));
        $logExample = $logFile[0];
        $log = new ApacheLogFile($logExample,$this->logFormats['common']);
        
        $method->invoke($log);
    }
    
    /**
     * @depends testParseLogCommonOne
     */
    public function testParseLogCommonAll(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','rows');
        $prop->setAccessible(true);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')
                ->with(m::type('string'),m::type('string'));
        $log = new ApacheLogFile(file_get_contents($this->logFiles['common']),
                $this->logFormats['common']);
        
        $method->invoke($log);
        $this->assertEquals(14,count($prop->getValue($log)));
    }

    /**
     * @depends testConvertFormatToRegExCombined
     */
    public function testParseLogCombinedOne(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')->once()
            ->with('clientIP','127.0.0.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('remoteLogname','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('user','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqTime','24/Mar/2012:21:55:14 -0500')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('request','GET / HTTP/1.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('lastStatus','200')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respBytes','199')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqHeader:Referer','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqHeader:User-Agent',
                    'Mozilla/5.0 (ABE, http://noscript.net/abe/wan)')->ordered();
        //set up test object
        $logFile = explode("\n", file_get_contents($this->logFiles['combined']));
        $logExample = $logFile[0];
        $log = new ApacheLogFile($logExample,$this->logFormats['combined']);
        
        $method->invoke($log);
    }
    
    /**
     * @depends testParseLogCombinedOne
     */
    public function testParseLogCombinedAll(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','rows');
        $prop->setAccessible(true);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')
                ->with(m::type('string'),m::type('string'));
        $log = new ApacheLogFile(file_get_contents($this->logFiles['combined']),
                $this->logFormats['combined']);
        
        $method->invoke($log);
        $this->assertEquals(10,count($prop->getValue($log)));
    }

    /**
     * @depends testConvertFormatToRegExAllStandard
     */
    public function testParseLogAllStandardOne(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        
        //set up mock expectations
        $expectedFinalArray = array('remoteIP','localIP','respBytes','respBytes',
            'respMicro','filename','clientIP','remoteLogname','reqMethod','port',
            'queryString','request','firstStatus','reqTime','respSec','user',
            'url','serverName','useCanonicalServerName','completeConnStatus',
            'libIOBytesIn','libIOBytesOut');
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')->once()
            ->with('remoteIP','127.0.0.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('localIP','192.168.0.104')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respBytes','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respBytes','0')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respMicro','10058')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('filename','/var/www/activity/logout.php')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('clientIP','127.0.0.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('remoteLogname','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqMethod','GET')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('port','80')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('queryString','')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('request','GET /activity/logout.php HTTP/1.1')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('firstStatus','303')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqTime','24/Mar/2012:22:05:48 -0500')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respSec','0')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('user','-')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('url','/activity/logout.php')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('serverName','www.example.com')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('useCanonicalServerName','www.example.com')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('completeConnStatus','+')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('libIOBytesIn','100')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('libIOBytesOut','3540')->ordered();
        //set up test object
        $logFile = explode("\n", file_get_contents($this->logFiles['allStandard']));
        $logExample = $logFile[0];
        $log = new ApacheLogFile($logExample,$this->logFormats['allStandard']);
        
        $method->invoke($log);
    }
    
    /**
     * @depends testParseLogAllStandardOne
     */
    public function testParseLogAllStandardAll(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','rows');
        $prop->setAccessible(true);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')
                ->with(m::type('string'),m::type('string'));
        $log = new ApacheLogFile(file_get_contents($this->logFiles['allStandard']),
                $this->logFormats['allStandard']);
        
        $method->invoke($log);
        $this->assertEquals(7,count($prop->getValue($log)));
    }

    /**
     * @depends testConvertFormatToRegExAllSegmented
     */
    public function testParseLogAllSegmentedOne(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')->once()
            ->with('cookie:foo','bar')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('environment:foo','baz')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('reqHeader:Referer',
                    'http://www.example.com/activity/page2.php?variable=7')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('module:foo','bar')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('respHeader:Server','Apache/2.4.1 (Unix) OpenSSL/1.0.0g')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('tid','3052276592')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('pid','27654')->ordered();
        $recordMock->shouldReceive('logValue')->once()
            ->with('lastStatus','200')->ordered();
        //set up test object
        $logFile = explode("\n", file_get_contents($this->logFiles['allSegmented']));
        $logExample = $logFile[0];
        $log = new ApacheLogFile($logExample,$this->logFormats['allSegmented']);
        
        $method->invoke($log);
    }
    
    /**
     * @depends testParseLogAllSegmentedOne
     */
    public function testParseLogAllSegmentedAll(){
        $method = new \ReflectionMethod(
          '\apacheLogParser\ApacheLogFile', '_parseLog'
        );
        $method->setAccessible(TRUE);
        $prop = new \ReflectionProperty('\apacheLogParser\ApacheLogFile','rows');
        $prop->setAccessible(true);
        
        //set up mock expectations
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')
                ->with(m::type('string'),m::type('string'));
        $log = new ApacheLogFile(file_get_contents($this->logFiles['allSegmented']),
                $this->logFormats['allSegmented']);
        
        $method->invoke($log);
        $this->assertEquals(4,count($prop->getValue($log)));
    }

    /**
     * @depends testParseLogCommonAll
     */
    public function testGetRowOneCommon(){
        $recordMock = m::mock('overload:apacheLogParser\ApacheLogRecord');
        $recordMock->shouldReceive('logValue')
                ->with(m::type('string'),m::type('string'));
        
        $log = new ApacheLogFile(file_get_contents($this->logFiles['common']),
                $this->logFormats['common']);
        
        $this->assertEquals(14,count($log->getRow()));
        $this->assertTrue($log->getRow(10) instanceof \apacheLogParser\ApacheLogRecord);
    }
}

?>
